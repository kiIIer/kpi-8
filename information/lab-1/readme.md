# Лабораторна робота №1

## Виконання

### Мова штучного інтелекту  
#### Завдання 1  
Опишіть, що відбувається при обчисленні таких висловлювань:

(a) `(+ (- 5 1) (+ 3 7))`

- `(- 5 1)` обчислюється як `4`.
- `(+ 3 7)` обчислюється як `10`.
- `(+ 4 10)` дає результат `14`.

(b) `(list 1 (+ 2 3))`

- `(+ 2 3)` обчислюється як `5`.
- `list` створює список з елементів `1` та `5`, отже результат — `(1 5)`.

(c) `(if (listp 1) (+ 1 2) (+ 3 4))`

- `listp 1` перевіряє, чи є `1` списком, повертає `NIL`.
- Оскільки `NIL` означає `false`, виконується `(+ 3 4)`, що дає `7`.

(d) `(list (and (listp 3) t) (+ 1 2))`

- `listp 3` перевіряє, чи є `3` списком, повертає `NIL`.
- `and (NIL t)` повертає `NIL`, бо `and` зупиняється на `NIL`.
- `(+ 1 2)` обчислюється як `3`.
- `list (NIL 3)` створює список, результат — `(NIL 3)`.

#### Завдання 2  
Побудуйте список `(a b c)` за допомогою трьох різних виразів, використовуючи функцію `cons`.  

Функція `cons` у Lisp використовується для створення пар елементів (cons-ячейок), які можуть бути об'єднані у списки. Для отримання списку `(a b c)`, ми можемо скласти три різні вирази, комбінуючи `cons` у різних варіантах.

Код з файлу [task1-2.lisp](code/task1-2.lisp)

```lisp
;; task1-2.lisp
(write-line "Варіант 1:")
(print (cons 'a (cons 'b (cons 'c nil))))

(write-line "Варіант 2:")
(print (cons 'a '(b c)))

(write-line "Варіант 3:")
(print (cons 'a (cons 'b '(c))))
```

![Виконання завдання 1-2](image.png)

#### Завдання 3  
Визначте функцію, яка повертає четвертий елемент списку, використовуючи `car` і `cdr`.

У Lisp `car` повертає перший елемент списку, а `cdr` — все, крім першого елемента. Щоб отримати четвертий елемент списку, потрібно тричі застосувати `cdr`, щоб поступово видаляти перші три елементи, а потім застосувати `car`, щоб вибрати перший елемент залишкового списку.

Код з файлу [task1-3.lisp](code/task1-3.lisp)

```lisp
(defun fourth-element (lst)
  (car (cdr (cdr (cdr lst)))))

;; Тестування:
(print (fourth-element '(a b c d e)))  ;; Результат: D
(print (fourth-element '(1 2 3 4 5 6)))  ;; Результат: 4
```

![Виконання завдання 1-3](image-1.png)

#### Завдання 4  

Визначте функцію, яка приймає два аргументи і повертає найбільший з них.

У Lisp для порівняння чисел використовується оператор `>`. Якщо перше число більше за друге, ми повертаємо його, інакше повертаємо друге число.

Код з файлу [task1-4.lisp](code/task1-4.lisp)

```lisp
(defun max-two (a b)
  (if (> a b) a b))

;; Тестування:
(print (max-two 5 10))  ;; Результат: 10
(print (max-two -3 7))  ;; Результат: 7
(print (max-two 4 4))   ;; Результат: 4
```

![Виконання завдання 1-4](image-2.png)

#### Завдання 5  

Проаналізуйте, що роблять наступні функції.

##### (a) `enigma`  
Функція `enigma` перевіряє, чи містить список хоча б один `NIL`. Вона працює рекурсивно:

1. Якщо `x` порожній (`NIL`), повертає `NIL`.
2. Якщо `car x` дорівнює `NIL`, повертає `T`.
3. Інакше рекурсивно викликає себе для `cdr x`.

Це означає, що функція перевіряє, чи є хоча б один `NIL` у списку.

##### (b) `mystery`  
Функція `mystery` знаходить **індекс першого входження елемента `x` у списку `y`**.

Як працює функція:
1. Якщо `y` порожній, повертає `NIL` (означає, що `x` не знайдено).
2. Якщо `car y` (перший елемент списку) дорівнює `x`, повертає `0` (знайдено на першій позиції).
3. В іншому випадку функція рекурсивно викликає себе для `cdr y` (решти списку).
4. Якщо в результаті рекурсії `x` знайдено, функція додає `1`, щоб врахувати зміщення індексу.

Код з файлу [task1-5.lisp](code/task1-5.lisp)

```lisp
(defun enigma (x)
  (and (not (null x)) 
       (or (null (car x)) 
           (enigma (cdr x)))))

(defun mystery (x y)
  (if (null y) 
      nil
      (if (eql (car y) x) 
          0
          (let ((z (mystery x (cdr y)))) 
            (and z (+ z 1))))))
  
;; Тестування:
(print (enigma '(1 2 nil 4)))  ;; Результат: T (є nil у списку)
(print (enigma '(1 2 3 4)))    ;; Результат: NIL (немає nil)

(print (mystery 2 '(1 2 3 2 4 2)))  ;; Результат: 1 (перша поява 2 на індексі 1)
(print (mystery 5 '(1 2 3 4)))      ;; Результат: NIL (елемента немає)
(print (mystery 3 '(1 2 3 4 3 5)))  ;; Результат: 2 (перша поява 3 на індексі 2)
```

![Виконання завдання 1-5](image-3.png)

##### Підсумок:
- **Функція `enigma`** перевіряє, чи є в списку хоча б один `NIL`.  
- **Функція `mystery`** знаходить індекс **першої появи** заданого елемента у списку.

#### Завдання 6  

Проаналізуйте, яке значення може стояти на місці `x` у наступних виразах.

##### **(a) `(car (x (cdr '(a (b c) d))))`**  
- `(cdr '(a (b c) d))` дає `((b c) d)`, тобто список без першого елемента `a`.  
- `x` застосовується до цього списку і повертає його перший елемент.  
- `car (...)` потім вибирає перший елемент результату.  

Щоб `x` працювало правильно, воно повинно бути `car`, оскільки `car ((b c) d)` поверне `(b c)`, а `car (b c)` дасть `b`.  
**Отже, `x = car`**.

##### **(b) `(x 13 (/ 1 0))`**  
- Вираз `(/ 1 0)` викликає ділення на нуль, що призводить до помилки.  
- Однак код працює, що означає, що `x` **ігнорує другий аргумент** і повертає перший.  
- У Lisp оператор `or` виконує коротке замикання (short-circuiting) — якщо перший аргумент істинний (не `NIL`), він одразу його повертає, **не обчислюючи** наступні.  

Тому `x` може бути просто `or`:
```lisp
(or 13 (/ 1 0))  ;; Поверне 13, а ділення не виконується
```
**Отже, `x = or`**.

##### **(c) `(x # 'list 1 nil)`**  
- `#'list` — це функція `list`, передана як об'єкт.  
- `x` застосовується до `list`, `1`, `nil`, і результат — `(1 NIL)`, але ми хочемо просто `(1)`.  
- Використання `apply` з `list*` виправляє проблему, оскільки `list*` передає останній аргумент як сам список, а не обгортає його в `NIL`.

**Отже, `x = apply`**.

---

Код з файлу [task1-6.lisp](code/task1-6.lisp)

```lisp
;; Варіант (a)
(print (car (car (cdr '(a (b c) d)))))  ;; Результат: B

;; Варіант (b)
(print (or 13 (/ 1 0)))  ;; Результат: 13

;; Варіант (c)
(print (apply #'list* '(1 nil)))  ;; Результат: (1)
```
![Результат виконання 1-6](image-4.png)

##### **Чому це працює?**
- **Варіант (a):** `car` витягує перший елемент з `cdr`, повертаючи `b`.  
- **Варіант (b):** `or` виконує коротке замикання: повертає `13`, не викликаючи `(/ 1 0)`.  
- **Варіант (c):** `apply #'list*` правильно формує `(1)` замість `(1 NIL)`, усуваючи небажане `NIL`.  


#### Завдання 7  

Визначте функцію, яка перевіряє, чи є списком хоча б один елемент списку. Користуйтеся тільки тими операторами, які були згадані в третій лекції.

##### **Аналіз завдання**  
- Функція повинна приймати список.  
- Перевіряти, чи хоча б один з його елементів є списком.  
- Використовувати лише оператори, які зустрічалися в лабораторній роботі: `car`, `cdr`, `cons`, `listp`, `null`, `if`, `and`, `or`.  

##### **Рішення**  
- Базовий випадок: якщо список порожній (`null`), повертаємо `NIL`.  
- Перевіряємо перший елемент списку (`car`), чи є він списком (`listp`).  
- Якщо `car` є списком, повертаємо `T`.  
- Інакше рекурсивно перевіряємо `cdr` списку.  

Код з файлу [task1-7.lisp](code/task1-7.lisp)

```lisp
(defun has-list? (lst)
  (if (null lst)
      nil  ;; Якщо список порожній, повертаємо NIL
      (or (listp (car lst))  ;; Якщо перший елемент список, повертаємо T
          (has-list? (cdr lst)))))  ;; Інакше перевіряємо решту списку

;; Тестування:
(print (has-list? '(1 2 3 4)))       ;; Результат: NIL (немає списків)
(print (has-list? '(1 (2 3) 4)))     ;; Результат: T (є список (2 3))
(print (has-list? '((1 2) (3 4))))   ;; Результат: T (перший елемент теж список)
(print (has-list? '()))              ;; Результат: NIL (порожній список)
```

![Результат виконання 1-7](image-5.png)

#### Завдання 8  

Запропонуйте ітеративне і рекурсивне визначення функції, яка:  

##### **(a) Друкує кількість точок, що дорівнює заданому позитивному цілому числу**  

###### **Рекурсивний підхід:**  
- Базовий випадок: якщо число дорівнює `0`, друк завершується.  
- Рекурсивно зменшуємо число і друкуємо `.` на кожному кроці.  

###### **Ітеративний підхід:**  
- Використовуємо цикл `dotimes`, який повторює друк `.` задану кількість разів.  

##### **(b) Повертає кількість символів `a` в заданому списку**  

###### **Рекурсивний підхід:**  
- Базовий випадок: якщо список порожній, повертаємо `0`.  
- Якщо `car` списку дорівнює `a`, додаємо `1` і рекурсивно рахуємо у `cdr`.  
- Якщо ні, просто рекурсивно рахуємо у `cdr`.  

###### **Ітеративний підхід:**  
- Проходимо список за допомогою `dolist`, перевіряючи кожен елемент.  
- Якщо він дорівнює `a`, збільшуємо лічильник.  

Код з файлу [task1-8.lisp](code/task1-8.lisp)  

```lisp
;; (a) Друкує кількість точок

;; Рекурсивний підхід
(defun print-dots-rec (n)
  (when (> n 0)
    (format t ".")
    (print-dots-rec (- n 1))))

;; Ітеративний підхід
(defun print-dots-iter (n)
  (dotimes (i n)
    (format t ".")))

;; (b) Підраховує кількість символів `a` у списку

;; Рекурсивний підхід
(defun count-a-rec (lst)
  (if (null lst)
      0
      (+ (if (eql (car lst) 'a) 1 0)
         (count-a-rec (cdr lst)))))

;; Ітеративний підхід
(defun count-a-iter (lst)
  (let ((count 0))
    (dolist (x lst count)
      (when (eql x 'a)
        (incf count)))))

;; Тестування:
(print-dots-rec 5)  ;; Результат: .....
(format t "~%")
(print-dots-iter 5)  ;; Результат: .....

(print (count-a-rec '(a b c a d a)))  ;; Результат: 3
(print (count-a-iter '(a b c a d a))) ;; Результат: 3
```

![Виконання завдання 1-8](image-6.png)

#### Завдання 9  

Ваш товариш намагався написати функцію, яка підсумовує всі значення елементів списку, крім `nil`. Він написав дві версії такої функції, але жодна з них не працює. Поясніть, що не так в кожній з них, і запропонуйте коректну версію.

##### **Аналіз помилок**  

###### **(a) `(defun summit (lst) (remove nil lst) (apply #’+ lst))`**  
**Помилки:**  
- `remove` повертає новий список без `nil`, але його результат не використовується.  
- `apply #’+ lst` працює на вихідному `lst`, який все ще містить `nil`, викликаючи помилку при додаванні.  

###### **(b) `(defun summit (lst) (let ((x (car lst))) (if (null x) (summit (cdr lst)) (+ x (summit (cdr lst))))))`**  
**Помилки:**  
- `null x` перевіряє, чи `car lst` є `nil`, але `nil` може бути відсутнім, що не гарантує правильну перевірку.  
- Якщо `car lst` є `nil`, функція просто пропускає його, що правильно, але у випадку `0` чи іншого значення, не гарантує правильного підсумовування.  
- Код не перевіряє базовий випадок, коли список порожній (`null lst`), що може спричинити помилку при виклику `cdr` на порожньому списку.  


##### **Коректна версія функції**
Код з файлу [task1-9.lisp](code/task1-9.lisp)  

```lisp
(defun summit (lst)
  (if (null lst)
      0  ;; Якщо список порожній, повертаємо 0
      (+ (if (null (car lst)) 0 (car lst))  ;; Ігноруємо nil, додаємо інші елементи
         (summit (cdr lst)))))  ;; Рекурсивно додаємо інші елементи

;; Тестування:
(print (summit '(1 2 3 nil 4)))  ;; Результат: 10
(print (summit '(nil nil 5 5)))  ;; Результат: 10
(print (summit '()))             ;; Результат: 0
(print (summit '(nil nil nil)))  ;; Результат: 0
```

![Виконання завдання 1-9](image-7.png)

##### **Пояснення коректної версії**  
- **Базовий випадок:** якщо список порожній, повертаємо `0`.  
- **Перевірка `car lst`:** якщо `car lst` є `nil`, додаємо `0`, інакше додаємо значення.  
- **Рекурсія:** обробляємо `cdr lst`, поступово підсумовуючи значення.  

#### Завдання 10  

Уявіть наступні списки у вигляді комірок.

##### **Аналіз структури списків у вигляді cons-ячейок**  

У Lisp списки реалізуються через `cons`-ячейки, де кожна комірка містить `car` (перший елемент) і `cdr` (решту списку). Давайте розглянемо, як представлені ці списки.

##### **(a) `(A b (c d))`**  
Цей список має три елементи:  
- `A`  
- `b`  
- `(c d)` (вкладений список)  

Запис у вигляді `cons`-ячейок:
```lisp
(cons 'A (cons 'b (cons (cons 'c (cons 'd nil)) nil)))
```

##### **(b) `(A (b (c (d))))`**  
Тут кожен вкладений список містить ще один вкладений список:  
- `A`  
- `(b (c (d)))`  

Запис у вигляді `cons`:
```lisp
(cons 'A (cons (cons 'b (cons (cons 'c (cons (cons 'd nil) nil)) nil)) nil))
```

##### **(c) `(((A b) c) d)`**  
Цей список містить вкладену пару:  
- `((A b) c)`  
- `d`  

Запис у вигляді `cons`:
```lisp
(cons (cons (cons 'A (cons 'b nil)) (cons 'c nil)) (cons 'd nil))
```

##### **(d) `(A (b . C) . D)`**  
- `A`  
- `(b . C)` (неправильний список, оскільки `C` є `cdr`)  
- `. D` (останній елемент у `cdr`)  

Запис у вигляді `cons`:
```lisp
(cons 'A (cons (cons 'b 'C) 'D))
```

##### **Висновок**  
Ці представлення допомагають зрозуміти, як Lisp-списки організовані всередині через `cons`-ячейки.

#### Завдання 11  

Напишіть свій варіант функції `union`, який зберігає порядок слідування елементів згідно з вихідними списками.

##### **Аналіз завдання**  
- Функція повинна об’єднати два списки.  
- Порядок елементів має відповідати їхній першій появі у вихідних списках.  
- Дублікатів у результаті бути не повинно.  

##### **Рішення**  
- Рекурсивно проходимо перший список і додаємо елементи до результату, якщо їх ще немає в об'єднаному списку.  
- Проходимо другий список і додаємо тільки ті елементи, які ще не були включені.  

Код з файлу [task1-11.lisp](code/task1-11.lisp)  

```lisp
(defun new-union (list1 list2)
  (let ((result nil))
    (dolist (x list1)
      (unless (member x result)
        (push x result)))
    (dolist (x list2)
      (unless (member x result)
        (push x result)))
    (nreverse result))) ;; Перевертаємо список, щоб зберегти правильний порядок

;; Тестування:
(print (new-union '(a b c) '(b a d)))  ;; Результат: (A B C D)
(print (new-union '(1 2 3) '(3 4 5)))  ;; Результат: (1 2 3 4 5)
(print (new-union '(x y) '(y z x)))    ;; Результат: (X Y Z)
(print (new-union '() '(a b c)))       ;; Результат: (A B C)
(print (new-union '(a b c) '()))       ;; Результат: (A B C)
```

![Виконання завдання 1-11](image-8.png)