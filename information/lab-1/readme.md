# Лабораторна робота №1

## Виконання

### Мова штучного інтелекту  
#### Завдання 1  
Опишіть, що відбувається при обчисленні таких висловлювань:

(a) `(+ (- 5 1) (+ 3 7))`

- `(- 5 1)` обчислюється як `4`.
- `(+ 3 7)` обчислюється як `10`.
- `(+ 4 10)` дає результат `14`.

(b) `(list 1 (+ 2 3))`

- `(+ 2 3)` обчислюється як `5`.
- `list` створює список з елементів `1` та `5`, отже результат — `(1 5)`.

(c) `(if (listp 1) (+ 1 2) (+ 3 4))`

- `listp 1` перевіряє, чи є `1` списком, повертає `NIL`.
- Оскільки `NIL` означає `false`, виконується `(+ 3 4)`, що дає `7`.

(d) `(list (and (listp 3) t) (+ 1 2))`

- `listp 3` перевіряє, чи є `3` списком, повертає `NIL`.
- `and (NIL t)` повертає `NIL`, бо `and` зупиняється на `NIL`.
- `(+ 1 2)` обчислюється як `3`.
- `list (NIL 3)` створює список, результат — `(NIL 3)`.

#### Завдання 2  
Побудуйте список `(a b c)` за допомогою трьох різних виразів, використовуючи функцію `cons`.  

Функція `cons` у Lisp використовується для створення пар елементів (cons-ячейок), які можуть бути об'єднані у списки. Для отримання списку `(a b c)`, ми можемо скласти три різні вирази, комбінуючи `cons` у різних варіантах.

Код з файлу [task1-2.lisp](code/task1-2.lisp)

```lisp
;; task1-2.lisp
(write-line "Варіант 1:")
(print (cons 'a (cons 'b (cons 'c nil))))

(write-line "Варіант 2:")
(print (cons 'a '(b c)))

(write-line "Варіант 3:")
(print (cons 'a (cons 'b '(c))))
```

![Виконання завдання 1-2](image.png)

#### Завдання 3  
Визначте функцію, яка повертає четвертий елемент списку, використовуючи `car` і `cdr`.

У Lisp `car` повертає перший елемент списку, а `cdr` — все, крім першого елемента. Щоб отримати четвертий елемент списку, потрібно тричі застосувати `cdr`, щоб поступово видаляти перші три елементи, а потім застосувати `car`, щоб вибрати перший елемент залишкового списку.

Код з файлу [task1-3.lisp](code/task1-3.lisp)

```lisp
(defun fourth-element (lst)
  (car (cdr (cdr (cdr lst)))))

;; Тестування:
(print (fourth-element '(a b c d e)))  ;; Результат: D
(print (fourth-element '(1 2 3 4 5 6)))  ;; Результат: 4
```

![Виконання завдання 1-3](image-1.png)

#### Завдання 4  

Визначте функцію, яка приймає два аргументи і повертає найбільший з них.

У Lisp для порівняння чисел використовується оператор `>`. Якщо перше число більше за друге, ми повертаємо його, інакше повертаємо друге число.

Код з файлу [task1-4.lisp](code/task1-4.lisp)

```lisp
(defun max-two (a b)
  (if (> a b) a b))

;; Тестування:
(print (max-two 5 10))  ;; Результат: 10
(print (max-two -3 7))  ;; Результат: 7
(print (max-two 4 4))   ;; Результат: 4
```

![Виконання завдання 1-4](image-2.png)

#### Завдання 5  

Проаналізуйте, що роблять наступні функції.

##### (a) `enigma`  
Функція `enigma` перевіряє, чи містить список хоча б один `NIL`. Вона працює рекурсивно:

1. Якщо `x` порожній (`NIL`), повертає `NIL`.
2. Якщо `car x` дорівнює `NIL`, повертає `T`.
3. Інакше рекурсивно викликає себе для `cdr x`.

Це означає, що функція перевіряє, чи є хоча б один `NIL` у списку.

##### (b) `mystery`  
Функція `mystery` знаходить **індекс першого входження елемента `x` у списку `y`**.

Як працює функція:
1. Якщо `y` порожній, повертає `NIL` (означає, що `x` не знайдено).
2. Якщо `car y` (перший елемент списку) дорівнює `x`, повертає `0` (знайдено на першій позиції).
3. В іншому випадку функція рекурсивно викликає себе для `cdr y` (решти списку).
4. Якщо в результаті рекурсії `x` знайдено, функція додає `1`, щоб врахувати зміщення індексу.

Код з файлу [task1-5.lisp](code/task1-5.lisp)

```lisp
(defun enigma (x)
  (and (not (null x)) 
       (or (null (car x)) 
           (enigma (cdr x)))))

(defun mystery (x y)
  (if (null y) 
      nil
      (if (eql (car y) x) 
          0
          (let ((z (mystery x (cdr y)))) 
            (and z (+ z 1))))))
  
;; Тестування:
(print (enigma '(1 2 nil 4)))  ;; Результат: T (є nil у списку)
(print (enigma '(1 2 3 4)))    ;; Результат: NIL (немає nil)

(print (mystery 2 '(1 2 3 2 4 2)))  ;; Результат: 1 (перша поява 2 на індексі 1)
(print (mystery 5 '(1 2 3 4)))      ;; Результат: NIL (елемента немає)
(print (mystery 3 '(1 2 3 4 3 5)))  ;; Результат: 2 (перша поява 3 на індексі 2)
```

![Виконання завдання 1-5](image-3.png)

##### Підсумок:
- **Функція `enigma`** перевіряє, чи є в списку хоча б один `NIL`.  
- **Функція `mystery`** знаходить індекс **першої появи** заданого елемента у списку.

#### Завдання 6  

Проаналізуйте, яке значення може стояти на місці `x` у наступних виразах.

##### **(a) `(car (x (cdr '(a (b c) d))))`**  
- `(cdr '(a (b c) d))` дає `((b c) d)`, тобто список без першого елемента `a`.  
- `x` застосовується до цього списку і повертає його перший елемент.  
- `car (...)` потім вибирає перший елемент результату.  

Щоб `x` працювало правильно, воно повинно бути `car`, оскільки `car ((b c) d)` поверне `(b c)`, а `car (b c)` дасть `b`.  
**Отже, `x = car`**.

##### **(b) `(x 13 (/ 1 0))`**  
- Вираз `(/ 1 0)` викликає ділення на нуль, що призводить до помилки.  
- Однак код працює, що означає, що `x` **ігнорує другий аргумент** і повертає перший.  

Це означає, що `x` може бути **функцією, яка просто повертає перший аргумент**, наприклад:  
```lisp
(lambda (a b) a)
```
або
```lisp
(defun first-arg (a b) a)
```

**Отже, `x = (lambda (a b) a)`**.

##### **(c) `(x # 'list 1 nil)`**  
- `#'list` — це функція `list`, передана як об'єкт.  
- `x` застосовується до `list`, `1`, `nil`, і результат — `(1 NIL)`, але ми хочемо просто `(1)`.  
- Використання `list*` замість `list` виправляє проблему, оскільки `list*` передає останній аргумент як сам список, а не обгортає його в `NIL`.

**Отже, `x = apply`**.

Код з файлу [task1-6.lisp](code/task1-6.lisp)

```lisp
;; Варіант (a)
(print (car (car (cdr '(a (b c) d)))))  ;; Результат: B

;; Варіант (b) - FIXED
(print ((lambda (a b) a) 13 (ignore-errors (/ 1 0))))  ;; Результат: 13

;; Варіант (c) - FIXED
(print (apply #'list* '(1 nil)))  ;; Результат: (1)
```

- **Варіант (a):** `car` витягує перший елемент з `cdr`, повертаючи `b`.  
- **Варіант (b):** `ignore-errors` запобігає помилці ділення на нуль, а `lambda (a b) a` повертає `13`.  
- **Варіант (c):** `apply #'list*` правильно формує `(1)` замість `(1 NIL)`, усуваючи небажане `NIL`.
