# Документація до мови представлення знань FRAMLisp

## 1. Вступ

FRAMLisp (Frame-based Representation and Management in Lisp) — це спеціалізована мова представлення знань, побудована на основі фреймової моделі. Вона дозволяє структуровано зберігати, редагувати та успадковувати знання у вигляді взаємопов’язаних об’єктів (фреймів). Мова реалізована на Common Lisp та забезпечує гнучкі механізми управління знаннями через структури фреймів, успадкування та динамічну модифікацію. Окрім стандартних операцій, FRAMLisp підтримує механізм демонів, який дозволяє автоматично виконувати процедури при зміні значень слотів.

---

## 2. Основні концепції FRAMLisp

FRAMLisp реалізує фреймову модель представлення знань, яка включає наступні компоненти:

1. **Фрейми** – об’єкти, що містять атрибути (слоти) та їхні значення.
2. **Слоти** – атрибути фреймів, які можуть містити дані, функції або посилання на інші фрейми.
3. **Аспекти слотів** – механізм для зберігання додаткових метаданих у слотах, таких як `$VALUE`, `$DEFAULT`, `$IF-ADDED`.
4. **Успадкування (AKO – "A Kind Of")** – механізм, що дозволяє одному фрейму отримувати атрибути іншого через зв’язок `AKO`.
5. **Глобальна база знань** – колекція всіх створених фреймів, що зберігається у змінній `*FRAMES*`.
6. **Демони** – спеціальні процедури, які автоматично виконуються при додаванні або зміні значення слота (аспект `$IF-ADDED`).

---

## 3. Переваги використання FRAMLisp

### 3.1. Гнучкість та модульність
- Фрейми можна створювати, змінювати та видаляти динамічно.
- Система дозволяє легко розширювати структуру знань, додаючи нові слоти та аспекти.

### 3.2. Підтримка успадкування
- Фрейми можуть успадковувати атрибути від інших фреймів.
- Якщо фрейм не містить потрібного атрибута, FRAMLisp автоматично шукає його у батьківському фреймі через зв’язок `AKO`.

### 3.3. Чітка структура та зрозумілий API
- FRAMLisp містить набір зручних функцій для роботи з фреймами.
- API дозволяє працювати з фреймами за допомогою простих команд, таких як `DEFRAMEQ`, `FREMOVE`, `FGET`, `FSET-PARENT` тощо.

### 3.4. Висока продуктивність
- Використання асоціативних списків (`assoc`) забезпечує швидкий доступ до знань.
- Вбудована перевірка існування фреймів дозволяє оптимізувати пошук.

### 3.5. Мінімізація дублювання даних
- Завдяки успадкуванню немає потреби дублювати інформацію в різних фреймах.
- Якщо дані змінюються в батьківському фреймі, вони автоматично оновлюються у всіх дочірніх фреймах.

---

## 4. Огляд функціоналу FRAMLisp

### 4.1. Основні операції з фреймами

#### Створення та оновлення фрейму

```lisp
(deframeq 'CAR
  '(BRAND ($VALUE "Tesla"))
  '(MODEL ($VALUE "Model S"))
  '(YEAR ($VALUE 2023)))
```

Функція `DEFRAMEQ` додає або оновлює фрейм `CAR` з трьома слотами.

#### Видалення фрейму

```lisp
(fremove 'CAR)
```

Функція `FREMOVE` повністю видаляє фрейм з бази.

#### Отримання списку фреймів

```lisp
(flist-frames)
```

Функція `FLIST-FRAMES` повертає список усіх фреймів у базі.

---

### 4.2. Робота зі слотами

#### Додавання або зміна слота

```lisp
(fassertq 'CAR '(COLOR ($VALUE "Red")))
```

Функція `FASSERTQ` додає слот `COLOR` до фрейму `CAR`.

#### Перевірка існування слота

```lisp
(fslot-exists? 'CAR 'BRAND)  ;; => T
```

Функція `FSLOT-EXISTS?` перевіряє, чи існує вказаний слот.

#### Перейменування слота

```lisp
(frename-slot 'CAR 'COLOR 'PAINT)
```

Функція `FRENAME-SLOT` змінює назву слота `COLOR` на `PAINT`.

---

### 4.3. Успадкування фреймів

#### Встановлення батьківського фрейму

```lisp
(fset-parent 'CAR 'TRANSPORT)
```

Після цього фрейм `CAR` успадковує всі слоти від `TRANSPORT`.

#### Отримання успадкованих значень

```lisp
(fget-inherited 'CAR 'MAX-SPEED)
```

Функція `FGET-INHERITED` спершу шукає значення у фреймі `CAR`, а якщо воно не знайдено – шукає у фреймі `TRANSPORT`.

---

### 4.4. Демони (автоматичні процедури)

FRAMLisp підтримує механізм демонів, який дозволяє виконувати процедури при зміні значень слотів. Це реалізовано через аспекти слотів, зокрема `$IF-ADDED`.

#### Функція `fattach-demon`

Прикріплює до слота фрейму процедуру-демон, яка зберігається як аспект `$IF-ADDED`. Якщо слот вже існує, демон додається або оновлюється; якщо слот відсутній – створюється новий слот із початковим значенням `$VALUE nil` та прикріпленим демоном.

```lisp
(defun fattach-demon (frame-name slot-name demon-func)
  "Прикріплює процедуру-демон demon-func до слота slot-name фрейму frame-name.
Демон зберігається як аспект $IF-ADDED у слоті.
Якщо слот або фрейм не існують, повертає NIL, інакше T."
  (let ((frame (assoc frame-name *FRAMES*)))
    (if frame
        (let ((slot (assoc slot-name (cdr frame))))
          (if slot
              (let ((demon-aspect (assoc '$IF-ADDED (cdr slot))))
                (if demon-aspect
                    (setf (cdr demon-aspect) demon-func)
                    (setf (cdr slot)
                          (cons (cons '$IF-ADDED demon-func)
                                (cdr slot))))
                t)
              (progn
                (setf (cdr frame)
                      (cons (list slot-name (list '$VALUE nil)
                                  (list '$IF-ADDED demon-func))
                            (cdr frame)))
                t)))
        nil)))
```

#### Функція `ftrigger-demon`

Перевіряє, чи прикріплено до слота аспект `$IF-ADDED`, і, якщо так, викликає його з параметрами: ім'я фрейму, ім'я слота та нове значення.

```lisp
(defun ftrigger-demon (frame-name slot-name new-value)
  "Якщо у слоту slot-name фрейму frame-name присутній аспект $IF-ADDED,
викликає його з параметрами (frame-name slot-name new-value) та повертає результат.
Якщо демон не визначено, повертає NIL."
  (let ((frame (assoc frame-name *FRAMES*)))
    (when frame
      (let ((slot (assoc slot-name (cdr frame))))
        (when slot
          (let ((demon-aspect (assoc '$IF-ADDED (cdr slot))))
            (when demon-aspect
              (funcall (cdr demon-aspect) frame-name slot-name new-value))))))))
```

#### Функція `fupdate-slot`

Оновлює значення аспекту `$VALUE` для заданого слота. Після оновлення значення автоматично викликається демон (якщо він прикріплений) через функцію `ftrigger-demon`.

```lisp
(defun fupdate-slot (frame-name slot-name new-value)
  "Оновлює значення слота slot-name у фреймі frame-name з новим значенням new-value.
Якщо у слоті визначено демон ($IF-ADDED), він буде викликаний.
Повертає T, якщо оновлення вдалося, інакше NIL."
  (let ((frame (assoc frame-name *FRAMES*)))
    (if frame
        (let ((slot (assoc slot-name (cdr frame))))
          (if slot
              (progn
                (let ((value-aspect (assoc '$VALUE (cdr slot))))
                  (if value-aspect
                      (setf (cdr value-aspect) (list new-value))
                      (push (list '$VALUE new-value) (cdr slot))))
                (ftrigger-demon frame-name slot-name new-value)
                t)
              (progn
                (push (list slot-name (list '$VALUE new-value))
                      (cdr frame))
                (ftrigger-demon frame-name slot-name new-value)
                t)))
        nil)))
```

#### Приклад використання демонів

1. **Створення фрейму PRODUCT:**

    ```lisp
    (deframeq 'PRODUCT
      '(NAME ($VALUE "Ноутбук"))
      '(PRICE ($VALUE 1000)))
    ```

2. **Прикріплення демона до слота PRICE:**

    ```lisp
    (fattach-demon 'PRODUCT 'PRICE
      (lambda (frm slot new-val)
        (format t "~%Демон: Значення слота ~A фрейму ~A змінено на ~A"
                slot frm new-val)
        (force-output t)))
    ```

3. **Оновлення значення слота PRICE:**

    ```lisp
    (fupdate-slot 'PRODUCT 'PRICE 1200)
    ;; Виведе: "Демон: Значення слота PRICE фрейму PRODUCT змінено на 1200"
    ```

---

## 5. Приклад використання FRAMLisp

### 5.1. Опис предметної області

Припустимо, ми хочемо представити знання про транспортні засоби.

#### Крок 1. Оголошення базового фрейму

```lisp
(deframeq 'TRANSPORT
  '(MAX-SPEED ($VALUE 100))
  '(TYPE ($VALUE "Generic Vehicle")))
```

#### Крок 2. Створення підкласу автомобілів

```lisp
(deframeq 'CAR
  '(BRAND ($VALUE "Tesla"))
  '(MODEL ($VALUE "Model S")))
(fset-parent 'CAR 'TRANSPORT)
```

#### Крок 3. Додавання додаткових властивостей

```lisp
(fassertq 'CAR '(FUEL ($VALUE "Electric")))
```

#### Крок 4. Отримання успадкованих значень

```lisp
(fget-inherited 'CAR 'MAX-SPEED)  ;; => (100)
(fget-inherited 'CAR 'BRAND)      ;; => ("Tesla")
```

### 5.2. Підсумковий вигляд бази знань

```lisp
(flist-frames)  ;; => (TRANSPORT CAR)
(fprint-slots 'CAR)
;; Вивід:
;; Слоти фрейма CAR:
;; - BRAND: ("Tesla")
;; - MODEL: ("Model S")
;; - FUEL: ("Electric")
;; - AKO: ("TRANSPORT")
```

---

## 6. Висновок

FRAMLisp забезпечує потужний та гнучкий підхід до представлення знань завдяки своїй структурі фреймів, механізму успадкування та підтримці демонів. Завдяки динамічній модифікації даних і автоматичному виконанню додаткових процедур при зміні значень слотів, система дозволяє ефективно управляти складними структурами знань. FRAMLisp є ефективним інструментом для розробників, що працюють у сферах експертних систем, штучного інтелекту та логічного виводу.